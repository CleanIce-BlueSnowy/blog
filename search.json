[{"title":"四大系统级编程语言对比（语言层面）","url":"/c_cpp_go_rust_cmp/","content":"本文进行四大系统级编程语言在语言层面的对比。发现本文勘误、不合理之处，可以进行指出。目前博客暂未启动评论区。\n本文进行对比时，均采用当时最新版本的语言。\n本文的大致框架：\n\n语言特性的对比。这部分包括语言的类型系统、内存管理、编程范式的对比。\n语言语法的对比。这部分包括语言的类型名称、类型声明方式、各种语句和语句块的写法的对比。\n程序结构化对比。这部分包括在语言的函数定义、结构（类）定义、枚举定义的写法的对比。\n数据共享的对比。这部分包括语言如何进行数据的共享（不复制）。\n程序设计的对比。这部分位于文章结尾，使用四种语言编写了一个最小生成树的算法，均使用工程代码规范。如果你想要快速地、全局地了解语言差异，优先阅读此部分。\n\n四大系统级编程语言\n本文所指的四大系统级编程语言分别是：C、C++、Go、Rust。这是目前公认的四种，即便 Go 语言存在一定争议。由于 Go 语言在性能上可以追上 C 与 C++，而语法上又大部分借鉴于 C 语言，使用方法也类似，也不止可以用在高并发网络领域，所以我们把 Go 也算作其中一员。\n关于本文的定义\n为了更好地对编程语言进行分类，本文中使用了一些基于又高于学界工人的分类标准和定义。我们会给出本文使用的分类标准的定义。\n语言特性对比\n类型系统\n定义：\n\n\n类型动态性：表示变量和数据的类型是否运行时可变。这是相对 JavaScript、Python 等语言而言的，并不是指面向对象中的多态的可变性。\n\n静态类型：表示不可变。\n动态类型：表示可变。\n\n\n\n类型严格性：表示允许的隐式类型转换与不同类型操作的程度。\n\n弱类型：表示默认就进行隐式类型转换，如 JavaScript 语言允许将一个字符串与一个数字进行操作、== 符号会进行很多类型转换。\n强类型：表示不允许不安全的隐式类型转换，但允许合理的隐式类型转换，如数值类型的互相转换等。\n严格类型：表示不允许几乎所有的隐式类型转换，哪怕是数值的转换等，强制要求类型匹配。\n\n\n\n共享数据类型：表示使用哪种方式的数据类型进行数据共享。仅从语言原始层面，不考虑标准库。\n\n基于指针：使用指针（底层是内存地址）进行数据共享。指针不拥有数据，但不要求数据存在。\n基于引用：使用引用进行数据共享。多个引用可以同时“拥有”一个数据。\n基于借用（所有权）：使用借用进行数据共享。一个数据只能有一个所有者，借用必须满足借用条件。\n\n\n\n\n\n\n语言\n类型动态性\n类型严格性\n共享数据类型\n\n\n\n\nC\n静态类型\n强类型\n基于指针\n\n\nC++\n静态类型\n强类型\n基于指针\n\n\nGo\n静态类型\n严格类型\n基于引用\n\n\nRust\n静态类型\n严格类型\n基于借用（所有权）\n\n\n\n提示\n\nGo 语言中有指针类型，但其指针类型行为与 Java 的引用类似，使用垃圾回收机制，所以归为基于引用的类型系统。\n\n\n内存管理\n定义：\n\n\n手动内存管理：手动进行内存的分配和释放。内存安全由程序员全权负责。\n\n\n智能指针管理：使用标准库提供的智能指针，将指针的内存管理自动化。程序员需要承担一定的内存安全责任。\n\n\n垃圾回收自动内存管理：基于垃圾回收的自动内存管理，程序仅分配，后台检查内存使用情况并自动释放。程序员一般不需要承担内存安全的责任。\n\n\n生命周期自动内存管理：基于静态的生命周期分析，编译时决定数据分配和释放的位置。程序员需要管理生命周期，但编译器承担内存安全的责任。\n\n\n对于智能指针管理和垃圾回收自动内存管理的区别，前者不需要运行时或者后台暂停，而后者需要。\n\n\n\n语言\n内存管理形式\n\n\n\n\nC\n手动内存管理\n\n\nC++\n手动内存管理\n\n\nGo\n垃圾回收自动内存管理\n\n\nRust\n生命周期自动内存管理\n\n\n\n提示\n\nC++ 有 std::shared_ptr 和 std::unique_ptr 等类型，它们是只能指针。但是它们是基于标准库实现的包装类型，只是将手动内存管理的任务包装起来了而已。所以在语言层面我们不认为 C++ 有智能指针管理。\nRust 语言中有 Rc 和 Arc 类型，它们也是智能指针。但它没有打破 Rust 的“一个数据只能有一个所有者”的限制，它仅仅包装了一个共享的数据，对于内部的这个数据来说，类似于多所有者。Rust 将 Rc 和 Arc 类型视作普通类型，一视同仁地进行生命周期分析，并决定分配和释放的位置，以及检查借用合法性。所以此处不认为 Rust 语言层面有智能指针管理。\n\n\n编程范式\n定义：\n\n\n过程式：与传统定义一致，强调代码的模块化，用函数或子过程分解问题。\n\n\n函数式：与传统定义一致，但没有那么严苛的要求，不一定需要纯函数式的内容，如不可变变量。\n\n\n面向对象：与传统定义基本一致，有多态、继承等概念。\n\n\n行为抽象：将某些类型的共同行为抽象出来，并且让这些类型实现该抽象。有些地方将此范式归入面向对象的范畴，但是两者在类型系统实现和编码习惯上有本质区别，而不仅仅是行为抽象没有继承等表面上的区别。\n\n\n泛型编程：与传统定义基本一致，在编写代码时不明确指定类型，在使用时以类似参数的形式确定类型。\n\n\n声明式：与命令式相对，描述目标性质和功能而非下达具体指令和步骤。如 SQL 语言。此类语言不一定要图灵完备。\n\n\n逻辑式：以数学逻辑表达式为基础构建程序，程序环境进行逻辑分析推理。如 Prolog 语言。\n\n\n标记式：以特定标记完成特定功能。如 HTML、Markdown、LaTeX 等。此类语言不一定要图灵完备，但也有完备者，如新兴排版编程语言 Typst。\n\n\n元编程：能够操作程序自身或其他程序结构，在编译时或运行时动态地进行修改代码，最常见的是反射机制。\n\n\n命令式：使用一系列明确的命令（或指令）排列组合构建程序，主要以改变程序状态进行编程。\n\n\n\n\n\n语言\n编程范式（第一位加粗为主要范式，后无先后顺序）\n\n\n\n\nC\n过程式  命令式\n\n\nC++\n面向对象  行为抽象：抽象类与纯抽象类  过程式  函数式：标准库提供  元编程：模板元编程和标准库提供的有限的运行时多类型  泛型编程：模板元编程  命令式\n\n\nGo\n行为抽象：使用接口 interface  过程式  函数式：部分  元编程：运行时反射，使用 reflect 包  泛型编程：后期引入类型参数  命令式\n\n\nRust\n行为抽象：使用特征 trait  过程式  函数式：极其强大的迭代器  元编程：编译时抽象语法树（AST）的修改，使用过程宏和属性宏  泛型编程  命令式\n\n\n\n语言语法对比\n数据类型对比\n\n\n\n类型\nC\nC++\nGo\nRust\n\n\n\n\n平台特定整数\nint 与 unsigned int\nint 与 uint\nusize 与 isize\n\n\n8 位整数\nint8_t 与 uint8_t\nstd::int8_t 与 std::uint8_t\nint8 与 uint8\ni8 与 u8\n\n\n16 位整数\nint16_t 与 uint16_t\nstd::int16_t 与 std::uint16_t\nint16 与 uint16\ni16 与 u16\n\n\n32 位整数\nint32_t 与 uint32_t\nstd::int32_t 与 std::uint32_t\nint32 与 uint32\ni32 与 u32\n\n\n64 位整数\nint64_t 与 uint64_t\nstd::int64_t 与 std::uint64_t\nint64 与 uint64\ni64 与 u64\n\n\n128 位整数\n标准内无\ni128 与 u128\n\n\n单精度浮点型\nfloat\nfloat32\nf32\n\n\n双精度浮点型\ndouble\nfloat64\nf64\n\n\n长双精度浮点型（硬件依赖）\nlong double\n标准内无\n标准内无\n\n\n布尔型\nbool\n\n\n单精度复数\nfloat _Complex\nstd::complex&lt;float&gt;\ncomplex64\nstd::complex::Complex&lt;f32&gt;\n\n\n双精度复数\ndouble _Complex\nstd::complex&lt;double&gt;\ncomplex128\nstd::complex::Complex&lt;f64&gt;\n\n\n高精度整数\n标准内无，需手动实现或第三方库\n内置 big.Int\n第三方库 num_bigint::BigInt\n\n\n高精度浮点数\n标准内无，需手动实现或第三方库\n内置 big.Float\n第三方库 decimal::d128\n\n\n分数 / 有理数\n标准内无，需手动实现\n第三方库 boost::rational&lt;int_type&gt;\n标准库扩展 big.Rat\n第三方库 num_rational::Ratio\n\n\n空类型 / 无返回类型\nvoid\n无显式，可用空结构 struct&#123;&#125;\n() 和 !\n\n\n共享数据类型（所有）\n指针 type*\n指针 type* 与引用 type&amp;\n类指针 *type\n借用 &amp;type 与 &amp;mut type\n\n\n字符类型\nchar 单字节 / UChar32 ICU 第三方库提供的 Unicode 字符\nchar 遗留单字节 / wchar_t 不推荐使用的宽字符 / char8_t UTF-8 / char16_t UTF-16 / char32_t UTF-32 或 Unicode 字符\nbyte 单字节 / rune Unicode 字符\nu8 单字节 / char Unicode 字符\n\n\n\n静态数组对比\n仅展示类型声明形式，不考虑变量等问题。\nC\nint array[100];\nC++\nint origin[100];  // 原始std::array&lt;int, 100&gt; modern;  // 现代\nGo\nvar array [100]int\nRust\nlet array = [i32; 100];\n动态数组对比\n仅展示类型声明形式，不考虑变量等问题。\nC\n手动实现。使用指针管理内存：\nint* array;\n动态分配和释放内存：\nint* array = malloc(3 * sizeof(int));  // 分配array[0] = 1;array[1] = 2;array[2] = 3;free(array);  // 释放\nC++\nstd::vector&lt;int&gt; array&#123; 1, 2, 3 &#125;;  // 初始化std::vector&lt;int&gt; arr_with_len(10);  // 带长度\nGo\narray := []int&#123; 1, 2, 3 &#125;  // 初始化arrWithLen := make([]int, 10)  // 带长度\nRust\n// 加了显示类型声明let array: Vec&lt;i32&gt; = vec![1, 2, 3];  // 初始化let arr_with_len: Vec&lt;_&gt; = vec![0; 10];  // 带长度，自动类型推导\n字符串对比\nC\nconst char* str1 = &quot;Hello!&quot;;  // 字面量char* str2 = malloc(7 * sizeof(char));  // 动态//  依靠第三方库 ICU 可以（很复杂地）实现 Unicode 字符串\nC++\nconst char* str1 = &quot;Hello!&quot;;  // 字面量std::string str2;  // 现代，可表示 UTF-8std::u16string str3;  // UTF-16std::u32string str4;  // UTF-32icu::UnicodeString str5;  // 第三方库 ICU\nGo\nstr1 := &quot;Hello!&quot;  // 字面量var str2 string  // 显式声明类型，UTF-8\nRust\nlet str1: &amp;str = &quot;Hello!&quot;;  // 字面量let str2: String;  // 动态，强制 UTF-8\n哈希表对比\nC\n手动实现。\nC++\nstd::unordered_map&lt;std::string, int&gt; table = &#123;    &#123; &quot;Perfect&quot;: 100 &#125;,    &#123; &quot;Excellent&quot;: 80&#125;,    &#123; &quot;Pass&quot;: 60 &#125;,    &#123; &quot;Fail&quot;: 0 &#125;,&#125;;\nGo\ntable := map[string]int&#123;\t&quot;Perfect&quot;: 100,\t&quot;Excellent&quot;: 80,\t&quot;Pass&quot;: 60,\t&quot;Fail&quot;: 0,&#125;\nRust\nlet mut table = HashMap::new();table.insert(&quot;Perfect&quot;, 100);table.insert(&quot;Excellent&quot;, 80);table.insert(&quot;Pass&quot;, 60);table.insert(&quot;Fail&quot;, 0);\n控制流对比\n条件判断\nC\nif (cond) &#123;    // ...&#125;if (cond) &#123;    // ...&#125; else &#123;    // ...&#125;if (cond1) &#123;    // ...&#125; else if (cond2) &#123;    // ...&#125; else if (cond3) &#123;    // ...&#125; else &#123;    // ...&#125;\nC++\nif (cond) &#123;    // ...&#125;if (cond) &#123;    // ...&#125; else &#123;    // ...&#125;if (cond1) &#123;    // ...&#125; else if (cond2) &#123;    // ...&#125; else if (cond3) &#123;    // ...&#125; else &#123;    // ...&#125;if (int num = 1; cond) &#123;  // 带初始临时变量    // ...&#125; // else-if else\nGo\nif cond &#123;\t// ...&#125;if cond &#123;\t// ...&#125; else &#123;\t// ...&#125;if cond1 &#123;\t// ...&#125; else if cond2 &#123;\t// ...&#125; else if cond3 &#123;\t// ...&#125; else &#123;\t// ...&#125;\nRust\nif cond &#123;    // ...&#125;if cond &#123;    // ...&#125; else &#123;    // ...&#125;if cond1 &#123;    // ...&#125; else if cond2 &#123;    // ...&#125; else if cond3 &#123;    // ...&#125; else &#123;    // ...&#125;if let Pattern = something &#123;  // 模式匹配判断    // ...&#125; // else-if else\n迭代循环\nC\nfor (int i = 0; i &lt; 100; i++) &#123;    // ...&#125;\nC++\nfor (int i = 0; i &lt; 100; i++) &#123;    // ...&#125;for (int i : std::views::iota(0, 100)) &#123;    // ...&#125;\nGo\nfor i := 0; i &lt; 100; i++ &#123;\t// ...&#125;for i := range [100]struct&#123;&#125; &#123;\t// ...&#125;\nRust\nfor i in 0..100 &#123;    // ...&#125;\n范围循环\nC\n无。\nC++\nfor (auto ele : something) &#123;    // ...&#125;\nGo\nfor _, ele := range something &#123;\t// ...&#125;\nRust\nfor ele in &amp;something &#123;    // ...&#125;for ele in something.iter() &#123;    // ...&#125;\n条件循环\nC\nwhile (cond) &#123;    // ...&#125;for (;cond;) &#123;    // ...&#125;\nC++\nwhile (cond) &#123;    // ...&#125;for (;cond;) &#123;    // ...&#125;\nGo\nfor cond &#123;\t// ...&#125;for ;cond; &#123;\t// ...&#125;\nRust\nwhile cond &#123;    // ...&#125;while let Pattern = something &#123;  // 模式匹配循环    // ...&#125;\n无限循环\nC\nwhile (true) &#123;    // ...&#125;for (;true;) &#123;    // ...&#125;for (;;) &#123;    // ...&#125;\nC++\nwhile (true) &#123;    // ...&#125;for (;true;) &#123;    // ...&#125;for (;;) &#123;    // ...&#125;\nGo\nfor &#123;\t// ...&#125;for true &#123;\t// ...&#125;for ;true; &#123;\t// ...&#125;for ;; &#123;\t// ...&#125;\nRust\nloop &#123;    // ...&#125;while true &#123;    // ...&#125;\n匹配选择\nC\nswitch (value) &#123;    case val1:        // ...        break;    case val2:        // ...        // fallthrough    case val3:        // ...        break;    default:        // ...        break;&#125;\nC++\nswitch (value) &#123;    case val1:        // ...        break;    case val2:        // ...        // fallthrough    case val3:        // ...        break;    default:        // ...        break;&#125;\nGo\nswitch value &#123;case val1:\t// ...case val2:\t// ...\tfallthroughcase val3:\t// ...default:\t// ...&#125;switch &#123;case cond1:  // 布尔条件\t// ...default:\t// ...&#125;\nRust\nmatch value &#123;  // 模式匹配    Pattern1 =&gt; /* ... */,    Pattern2 =&gt; &#123;        // ...    &#125;    Pattern3 =&gt; &#123;        // ...    &#125;    _ =&gt; &#123;        // ...    &#125;&#125;\n程序结构化对比\n函数\nC\n// 无参无返回void no_arg_no_ret() &#123;    // ...&#125;// 旧式void no_arg_no_ret_old(void) &#123;    // ...&#125;// 无参有返回int no_arg_has_ret() &#123;    return 1;&#125;int no_arg_has_ret_old(void) &#123;    return 1;&#125;// 有参无返回void has_arg_no_ret(int a, double b) &#123;    // ...&#125;// 有参有返回int has_arg_has_ret(int a, int b) &#123;    return a + b;&#125;\nC++\n// 无参无返回void no_arg_no_ret() &#123;    // ...&#125;auto no_arg_no_ret_new() -&gt; void &#123;    // ...&#125;// 无参有返回int no_arg_has_ret() &#123;    return 1;&#125;auto no_arg_has_ret_auto() &#123;    return 1;&#125;auto no_arg_has_ret_new() -&gt; int &#123;    return 1;&#125;// 有参无返回void has_arg_no_ret(int a, double b) &#123;    // ...&#125;auto has_arg_no_ret_new(int a, double b) -&gt; void &#123;    // ...&#125;// 有参有返回int has_arg_has_ret(int a, int b) &#123;    return a + b;&#125;auto has_arg_has_ret_auto(int a, int b) &#123;    return a + b;&#125;auto has_arg_has_ret_decl(int a, int b) -&gt; decltype(a + b) &#123;    return a + b;&#125;auto has_arg_has_ret_new(int a, int b) -&gt; int &#123;    return a + b;&#125;\nGo\n// 无参无返回func NoArgNoRet() &#123;\t// ...&#125;// 无参有返回func NoArgHasRet() int &#123;\treturn 1&#125;func NoArgHasRetWithName() ret int &#123;\tret := 1\treturn&#125;// 有参无返回func HasArgNoRet(a int, b float64) &#123;\t// ...&#125;// 有参有返回func HasArgHasRet(a, b int) int &#123;\treturn a + b&#125;func HasArgHasRetWithName(a, b int) sum int &#123;\tsum := a + b\treturn&#125;func HasArgHasRetExplicitTypes(a int, b int) int &#123;\treturn a + b&#125;\nRust\n// 无参无返回fn no_arg_no_ret() &#123;    // ...&#125;// 无参有返回fn no_arg_has_ret() -&gt; i32 &#123;    1&#125;fn no_arg_has_ret_with_return() -&gt; i32 &#123;    return 1;&#125;// 有参无返回fn has_arg_no_ret(a: i32, b: f64) &#123;    // ...&#125;// 有参有返回fn has_arg_has_ret(a: i32, b: i32) -&gt; i32 &#123;    a + b&#125;fn has_arg_has_ret_with_return(a: i32, b: i32) -&gt; i32 &#123;    return a + b;&#125;\n结构（类）定义\nC\nstruct Type &#123;    int a;    double b;    char c;    const char* name;&#125;;\nC++\nstruct Type &#123;    // 默认 public    int a;public:    double b;protected:    char c;private:    std::string name;public:    void method() &#123;        // ...    &#125;    static void static_method() &#123;        // ...    &#125;&#125;;class TypeClass &#123;    // 默认 private    int a;public:    double b;protected:    char c;private:    std::string name;public:    void method() &#123;        // ...    &#125;    static void static_method() &#123;        // ...    &#125;&#125;;\nGo\ntype Type struct &#123;\ta int\tb float64\tc rune\tName string  // public&#125;func (this *Type) Method() &#123;\t// ...&#125;\nRust\nstruct Type &#123;    a: i32;    b: f64;    c: char;    pub name: String;  // public&#125;impl Type &#123;    pub fn method(&amp;self) &#123;        // ...    &#125;    pub fn static_method() &#123;        // ...    &#125;&#125;\n枚举定义\nC\nenum Day &#123;    Sun,    Mon,    Tue,    Wed,    Thu,    Fri,    Sat,&#125;;\nC++\nenum Day &#123;    Sun,    Mon,    Tue,    Wed,    Thu,    Fri,    Sat,&#125;;enum class DayEnum &#123;    Sun,    Mon,    Tue,    Wed,    Thu,    Fri,    Sat,&#125;;\nGo\nconst (\tSun = iota\tMon\tTue\tWed\tThu\tFri\tSat)\nRust\nenum Day &#123;    Sun,    Mon,    Tue,    Wed,    Thu,    Fri,    Sat&#125;// 枚举变体enum Message &#123;    Shutdown,    Send(String),    Error &#123;        code: usize,        msg: String,    &#125;,    Sleep(usize, usize),&#125;\n数据共享对比\nC\n指针\nint number = 1;int* pointer = &amp;number;  // 获取指针int other = *pointer;  // 获取指针值*pointer = 2;  // 设置指针值pointer = &amp;other;  // 重设目标\n指向不可变指针（常量指针）\nint number = 1;int* const pointer = &amp;number;int other = *pointer;*pointer = 2;// pointer = &amp;other;  --- Error\n数据不可变指针（指向常量的指针）\nint number = 1;const int* pointer = &amp;number;int other = *pointer;// *pointer = 2;  --- Errorpointer = &amp;other;\n指向与数据不可变指针（指向常量的常量指针）\nint number = 1;const int* const pointer = &amp;number;int other = *pointer;// *pointer = 2;  --- Error// pointer = &amp;other;  --- Error\nC++\n指针\n与 C 语言完全一致。\n引用\nint number = 1;int&amp; reference = number;  // 创建引用int other = reference;  // 读取引用值reference = 2;  // 设置引用值\n不可变引用\nint number = 1;const int&amp; reference = number;int other = reference;// reference = 2;  --- Error\nGo\n指针\n显式定义类型：\nvar number int = 1var pointer *int = &amp;number  // 创建指针var other int = *pointer  // 读取指针值*pointer = 2  // 设置指针值pointer = &amp;other  // 重设目标\n简写声明：\nnumber := 1pointer := &amp;numberother := *pointer*pointer = 2pointer = &amp;other\nRust\n可变借用\nlet mut number = 1;let borrow = &amp;mut number;  // 创建借用let mut other = *borrow;  // 读取借用值（若实现 Copy 则复制，否则转移所有权）*borrow = 2;  // 设置借用值（若实现 Copy 则复制，否则转移所有权）// borrow = &amp;mut other;  --- 需要 mut 变量才能重设目标\n不可变借用\nlet number = 1;let borrow = &amp;number;let other = *borrow;// *borrow = 2;  --- Error\n程序设计对比\n接下来，我们用这四种语言实现同一个程序，来从全局的角度对比一下这四种语言。\n程序目标\n输入一个无向带权图，该图不一定连通。求出此图的最小生成树的边权之和，如果此图不连通，则输出 Not connected.。\n从标准输入读取图的信息。第一行两个整 VVV 与 EEE，表示图的点数与边数。接下来共 MMM 行，每行参个整数 aaa、bbb、www，代表点 aaa 与点 bbb 之间有一条无向边，边权是 www。\n将结果输出到标准输出。如果该图连通，输出最小生成树的边权之和；否则，输出 Not connected.。\n点的序号 aaa 和 bbb 采用以 1-based 索引（即索引从 1 开始）。\n程序设计\n我们使用 Kruskal 算法求最小生成树。简单说明一下算法思路：输入所有边后，对边按照边权升序排序，并从最小边权的边开始处理。使用并查集来处理哪些顶点在已知的最小生成树中，哪些不在。每次处理一条边时，需要判断这个边所连接的两个点是否已经都在最小生成树中了，也就是这两个点是否已经在并查集中连通了。只要有一个点不在已知的最小生成树中，我们将此边加入最小生成树，在并查集中连通两个顶点，并累加边权。这是一种典型的贪心算法，时间复杂度为 O(Elog⁡E)O\\left(E \\log E\\right)O(ElogE)，空间复杂度为 O(E+V)O\\left(E + V\\right)O(E+V)，其中 EEE 是边数，VVV 是点数，计算机科学中对数的默认底为 222。\n根据树的性质：边段数量为点的数量减一。所以当我们处理了足够多的边时，停止处理并输出累加边权。\n如果最后所有的边处理完成但是已知的最小生成树中还没有足够的边，说明原图不连通。这时我们输出 Not connected.。\n标准输入的节点是 1-based 索引，为了方便处理，我们在进行数据输入时就将其转换为 0-based 索引。\n关于图、树、最小生成树、Kruskal 算法、贪心算法等内容，感兴趣的可以自行搜索更多资料。\n代码\nC\n#include &lt;inttypes.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int32_t int32;typedef size_t usize;typedef struct &#123;    int32* father;&#125; UnionFind;typedef struct &#123;    int32 a;    int32 b;    int32 weight;&#125; Edge;int edge_cmp(const void* a, const void* b);void read_data(usize* node_cnt, usize* edge_cnt, Edge** const edges);bool kruskal(const usize node_cnt, const usize edge_cnt, Edge* const edges, int32* const result);UnionFind* create_union_find(const usize size);void free_union_find(UnionFind* const self);int32 find_root(UnionFind* const self, const int32 a);bool connected(UnionFind* const self, const int32 a, const int32 b);void merge(UnionFind* const self, const int32 a, const int32 b);int main() &#123;    usize node_cnt = 0;    usize edge_cnt = 0;    Edge* edges = NULL;    read_data(&amp;node_cnt, &amp;edge_cnt, &amp;edges);    int32 result = -1;    const bool succeeded = kruskal(node_cnt, edge_cnt, edges, &amp;result);    if (succeeded) &#123;        printf(&quot;%&quot; PRId32 &quot;\\n&quot;, result);    &#125; else &#123;        printf(&quot;Not connected.\\n&quot;);    &#125;    free(edges);    return 0;&#125;int edge_cmp(const void* a, const void* b) &#123;    const Edge* edge_a = (const Edge*) a;    const Edge* edge_b = (const Edge*) b;    if (edge_a-&gt;weight &lt; edge_b-&gt;weight) &#123;        return -1;    &#125; else if (edge_a-&gt;weight &gt; edge_b-&gt;weight) &#123;        return 1;    &#125; else &#123;        return 0;    &#125;&#125;void read_data(usize* node_cnt, usize* edge_cnt, Edge** const edges) &#123;    const int input_res = scanf(&quot;%zu%zu&quot;, node_cnt, edge_cnt);    if (input_res != 2) &#123;        exit(1);    &#125;    *edges = (Edge*) malloc(*edge_cnt * sizeof(Edge));    if (*edges == NULL) &#123;        exit(1);    &#125;    for (usize i = 0; i &lt; *edge_cnt; i++) &#123;        int32 a, b, weight;        const int input_res = scanf(&quot;%&quot; PRId32 &quot;%&quot; PRId32 &quot;%&quot; PRId32, &amp;a, &amp;b, &amp;weight);        if (input_res != 3) &#123;            exit(1);        &#125;        (*edges)[i] = (Edge)&#123;            .a = a - 1,            .b = b - 1,            .weight = weight,        &#125;;    &#125;&#125;bool kruskal(const usize node_cnt, const usize edge_cnt, Edge* const edges, int32* const result) &#123;    qsort(edges, edge_cnt, sizeof(Edge), edge_cmp);    UnionFind* const set = create_union_find(node_cnt);    int32 total = 0;    int32 handled = 0;    for (usize i = 0; i &lt; edge_cnt; i++) &#123;        const Edge* const edge = &amp;edges[i];        if (connected(set, edge-&gt;a, edge-&gt;b)) &#123;            continue;        &#125;        merge(set, edge-&gt;a, edge-&gt;b);        total += edge-&gt;weight;        handled++;        if (handled == (int32) node_cnt - 1) &#123;            *result = total;            free_union_find(set);            return true;        &#125;    &#125;    free_union_find(set);    return false;&#125;UnionFind* create_union_find(const usize size) &#123;    UnionFind* const self = (UnionFind* const) malloc(sizeof(UnionFind));    if (self == NULL) &#123;        exit(1);    &#125;    self-&gt;father = (int32*) malloc(size * sizeof(int32));    if (self-&gt;father == NULL) &#123;        exit(1);    &#125;    for (usize i = 0; i &lt; size; i++) &#123;        self-&gt;father[i] = (int32) i;    &#125;    return self;&#125;void free_union_find(UnionFind* const self) &#123;    free(self-&gt;father);    free(self);&#125;int32 find_root(UnionFind* const self, const int32 a) &#123;    if (self-&gt;father[a] == a) &#123;        return a;    &#125;    const int32 temp = find_root(self, self-&gt;father[a]);    self-&gt;father[a] = temp;    return temp;&#125;bool connected(UnionFind* const self, const int32 a, const int32 b) &#123;    return find_root(self, a) == find_root(self, b);&#125;void merge(UnionFind* const self, const int32 a, const int32 b) &#123;    const int32 root_a = find_root(self, a);    const int32 root_b = find_root(self, b);    self-&gt;father[root_a] = root_b;&#125;\nC++\n#include &lt;algorithm&gt;#include &lt;cstdint&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;optional&gt;#include &lt;tuple&gt;#include &lt;vector&gt;using int32 = std::int32_t;using usize = std::size_t;class UnionFind final &#123;private:    const std::unique_ptr&lt;int32[]&gt; father;    auto find_root(const int32 a) -&gt; int32;public:    UnionFind(const usize size);    auto connected(const int32 a, const int32 b) -&gt; bool;    void merge(const int32 a, const int32 b);&#125;;class Edge final &#123;public:    int32 a;    int32 b;    int32 weight;    Edge(const int32 a, const int32 b, const int32 weight);&#125;;auto read_data() -&gt; std::tuple&lt;usize, std::vector&lt;Edge&gt;&gt;;auto kruskal(const usize node_cnt, std::vector&lt;Edge&gt;&amp; edges) -&gt; std::optional&lt;int32&gt;;auto main() -&gt; int &#123;    auto [node_cnt, edges] = read_data();    const std::optional&lt;int32&gt; result = kruskal(node_cnt, edges);    if (result.has_value()) &#123;        std::cout &lt;&lt; result.value() &lt;&lt; &#x27;\\n&#x27;;    &#125; else &#123;        std::cout &lt;&lt; &quot;Not connected.&quot; &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;auto read_data() -&gt; std::tuple&lt;usize, std::vector&lt;Edge&gt;&gt; &#123;    usize node_cnt, edge_cnt;    std::cin &gt;&gt; node_cnt &gt;&gt; edge_cnt;    std::vector&lt;Edge&gt; edges;    for (usize i = 0; i &lt; edge_cnt; i++) &#123;        int32 a, b, weight;        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; weight;        edges.push_back(Edge(a - 1, b - 1, weight));    &#125;    return std::make_tuple(node_cnt, std::move(edges));&#125;auto kruskal(const usize node_cnt, std::vector&lt;Edge&gt;&amp; edges) -&gt; std::optional&lt;int32&gt; &#123;    std::ranges::sort(edges, [](const Edge&amp; a, const Edge&amp; b) -&gt; bool &#123;        return a.weight &lt; b.weight;    &#125;);    UnionFind set(node_cnt);    int32 total = 0;    int32 handled = 0;    for (const Edge&amp; edge : edges) &#123;        if (set.connected(edge.a, edge.b)) &#123;            continue;        &#125;        set.merge(edge.a, edge.b);        total += edge.weight;        handled++;        if (handled == static_cast&lt;int32&gt;(node_cnt) - 1) &#123;            return std::make_optional(total);        &#125;    &#125;    return std::nullopt;&#125;UnionFind::UnionFind(const usize size) : father(std::make_unique&lt;int32[]&gt;(size)) &#123;    for (usize i = 0; i &lt; size; i++) &#123;        father[i] = static_cast&lt;int32&gt;(i);    &#125;&#125;auto UnionFind::connected(const int32 a, const int32 b) -&gt; bool &#123;    return find_root(a) == find_root(b);&#125;void UnionFind::merge(const int32 a, const int32 b) &#123;    const int32 root_a = find_root(a);    const int32 root_b = find_root(b);    father[root_a] = root_b;&#125;auto UnionFind::find_root(const int32 a) -&gt; int32 &#123;    if (father[a] == a) &#123;        return a;    &#125;    const int32 temp = find_root(father[a]);    father[a] = temp;    return temp;&#125;Edge::Edge(const int32 a, const int32 b, const int32 weight) : a(a), b(b), weight(weight) &#123;&#125;\nGo\npackage mainimport (\t&quot;fmt&quot;\t&quot;sort&quot;)type UnionFind struct &#123;\tfather []int&#125;type Edge struct &#123;\ta int\tb int\tweight int&#125;func main() &#123;\tnodeCnt, edges := readData()\tresult := kruskal(nodeCnt, edges)\tif result != nil &#123;\t\tfmt.Println(*result)\t&#125; else &#123;\t\tfmt.Println(&quot;Not connected.&quot;)\t&#125;&#125;func readData() (nodeCnt int, edges []Edge) &#123;\tvar edgeCnt int\tfmt.Scan(&amp;nodeCnt, &amp;edgeCnt)\tedges = make([]Edge, edgeCnt)\tfor i := range edgeCnt &#123;\t\tvar a, b, weight int\t\tfmt.Scan(&amp;a, &amp;b, &amp;weight)\t\tedges[i] = Edge &#123;\t\t\ta: a - 1,\t\t\tb: b - 1,\t\t\tweight: weight,\t\t&#125;\t&#125;\treturn&#125;func kruskal(nodeCnt int, edges []Edge) *int &#123;\tsort.Slice(edges, func(i, j int) bool &#123;\t\treturn edges[i].weight &lt; edges[j].weight\t&#125;)\tset := newUnionFind(nodeCnt)\ttotal := 0\thandled := 0\tfor _, edge := range edges &#123;\t\tif set.connected(edge.a, edge.b) &#123;\t\t\tcontinue\t\t&#125;\t\tset.merge(edge.a, edge.b)\t\ttotal += edge.weight\t\thandled++\t\tif handled == nodeCnt - 1 &#123;\t\t\treturn &amp;total\t\t&#125;\t&#125;\treturn nil&#125;func newUnionFind(size int) *UnionFind &#123;\tset := UnionFind &#123;\t\tfather: make([]int, size),\t&#125;\tfor i := range size &#123;\t\tset.father[i] = i\t&#125;\treturn &amp;set&#125;func (set *UnionFind) connected(a, b int) bool &#123;\treturn set.findRoot(a) == set.findRoot(b)&#125;func (set *UnionFind) merge(a, b int) &#123;\trootA := set.findRoot(a)\trootB := set.findRoot(b)\tset.father[rootA] = rootB&#125;func (set *UnionFind) findRoot(a int) int &#123;\tif set.father[a] == a &#123;\t\treturn a\t&#125;\ttemp := set.findRoot(set.father[a])\tset.father[a] = temp\treturn temp&#125;\nRust\nstruct UnionFind &#123;    father: Box&lt;[i32]&gt;,&#125;struct Edge &#123;    a: i32,    b: i32,    weight: i32,&#125;fn main() &#123;    let (node_cnt, mut edges) = read_data(&amp;std::io::stdin());    let result = kruskal(node_cnt, &amp;mut edges);    if let Some(res) = result &#123;        println!(&quot;&#123;res&#125;&quot;);    &#125; else &#123;        println!(&quot;Not connected.&quot;);    &#125;&#125;fn read_data(reader: &amp;std::io::Stdin) -&gt; (usize, Vec&lt;Edge&gt;) &#123;    let mut line = String::new();    reader.read_line(&amp;mut line).unwrap();    let mut iter = line.trim().split(&#x27; &#x27;).map(|x| x.parse::&lt;usize&gt;().unwrap());    let node_cnt = iter.next().unwrap();    let edge_cnt = iter.next().unwrap();    let mut edges = vec![];    for _i in 0..edge_cnt &#123;        let mut line = String::new();        reader.read_line(&amp;mut line).unwrap();        let mut iter = line.trim().split(&#x27; &#x27;).map(|x| x.parse::&lt;i32&gt;().unwrap());        let a = iter.next().unwrap();        let b = iter.next().unwrap();        let weight = iter.next().unwrap();        edges.push(Edge &#123;            a,            b,            weight,        &#125;);    &#125;    (node_cnt, edges)&#125;fn kruskal(node_cnt: usize, edges: &amp;mut [Edge]) -&gt; Option&lt;i32&gt; &#123;    edges.sort_by_key(|x| x.weight);    let mut set = UnionFind::new(node_cnt);    let mut total = 0;    let mut handled = 0;    for edge in edges &#123;        if set.connected(edge.a, edge.b) &#123;            continue;        &#125;        set.merge(edge.a, edge.b);        total += edge.weight;        handled += 1;        if handled == (node_cnt as i32) - 1 &#123;            return Some(total);        &#125;    &#125;    None&#125;impl UnionFind &#123;    fn new(size: usize) -&gt; Self &#123;        let mut this = UnionFind &#123;            father: vec![0; size].into_boxed_slice(),        &#125;;        for i in 0..size &#123;            this.father[i] = i as i32;        &#125;        this    &#125;    fn connected(&amp;mut self, a: i32, b: i32) -&gt; bool &#123;        self.find_root(a) == self.find_root(b)    &#125;    fn merge(&amp;mut self, a: i32, b: i32) &#123;        let root_a = self.find_root(a);        let root_b = self.find_root(b);        self.father[root_a as usize] = root_b;    &#125;    fn find_root(&amp;mut self, a: i32) -&gt; i32 &#123;        if self.father[a as usize] == a &#123;            a        &#125; else &#123;            let temp = self.find_root(self.father[a as usize]);            self.father[a as usize] = temp;            temp        &#125;    &#125;&#125;\n"}]